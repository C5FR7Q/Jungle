package com.example.myapplication.base

import android.app.Activity
import android.content.Context
import android.os.Build
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.DialogFragment
import dagger.android.DispatchingAndroidInjector
import dagger.android.HasAndroidInjector
import dagger.android.support.AndroidSupportInjection
import javax.inject.Inject

abstract class BaseFragment : DialogFragment(), HasAndroidInjector {

	@Inject
	lateinit var androidInjector: DispatchingAndroidInjector<Any>

	abstract val containerID: Int

	/*
	 * The property `childFragmentManager` cannot be declared here with that name as it results in
	 * an 'accidental override' compile-time error. Kotlin automatically generates getters for
	 * properties. In this case, Kotlin generates a method called `getChildFragmentManager()` for
	 * the property `childFragmentManager`, which then conflicts with the Fragment's
	 * `getChildFragmentManager()` method.
	 *
	 * There are workarounds to this;
	 *
	 * 1. Change the property name to something else such as `fragmentChildFragmentManager`.
	 * 2. Rename the getter generated by Kotlin using @get:JvmName("fragmentChildFragmentManager")
	 *
	 * However, we will not be doing any of the above because subclasses would have to use our
	 * custom getter/property instead of the builtin `childFragmentManager`, which may cause
	 * confusion.
	 *
	 * The caveat to this is that we would need to use Robolectric in our tests in order to mock and
	 * verify `FragmentManager` usages. For more details around testing `FragmentManager` usages,
	 * see https://github.com/vestrel00/android-dagger-butterknife-mvp/pull/52.
	 */
	// @Inject
	// @field:Named(BaseFragmentModule.CHILD_FRAGMENT_MANAGER)
	// protected lateinit var childFragmentManager: FragmentManager

	/*
	 * This coincides with workaround #1 from the above comment about `childFragmentManager`. We'll
	 * just use the `context` reference provided by Kotlin (from the Fragment's `getContext()`
	 * method).
	 */
	// @Inject
	// protected lateinit var activityContext: Context

	@SuppressWarnings("DEPRECATION")
	override fun onAttach(activity: Activity) {
		if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
			// Perform injection here for versions before M as onAttach(*Context*) did not yet exist
			// This fixes DaggerFragment issue: https://github.com/google/dagger/issues/777
			AndroidSupportInjection.inject(this)
		}
		super.onAttach(activity)
	}

	final override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
		return inflater.inflate(containerID, container, false)
	}

	override fun onAttach(context: Context) {
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
			// Perform injection here for M (API 23) due to deprecation of onAttach(*Activity*).
			AndroidSupportInjection.inject(this)
		}
		super.onAttach(context)
	}

	override fun androidInjector() = androidInjector
}